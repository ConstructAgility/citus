-- This file includes tests for schema support


CREATE SCHEMA tpch;

-- Set the search path to tpch
SET search_path TO tpch;

-- Below tests cover the followings on different schemas:
-- Create table, create shards for both hash and append partition tables
-- drop shards via master_apply_delete_command()

CREATE TABLE nation_append (
    n_nationkey integer not null,
    n_name char(25) not null,
    n_regionkey integer not null,
    n_comment varchar(152));
SELECT master_create_distributed_table('nation_append', 'n_nationkey', 'append');

\COPY nation_append FROM '@abs_srcdir@/data/nation.data' with delimiter '|'

SELECT master_create_empty_shard('nation_append');
SELECT count(*) FROM nation_append;

-- Set the search path to public
SET search_path TO public;

\COPY tpch.nation_append FROM '@abs_srcdir@/data/nation.data' with delimiter '|'

SELECT master_create_empty_shard('nation_append');
SELECT count(*) FROM tpch.nation_append;

-- Set the search path to public
SET search_path TO public;

CREATE TABLE tpch.nation_hash (
    n_nationkey integer not null,
    n_name char(25) not null,
    n_regionkey integer not null,
    n_comment varchar(152));

SELECT master_create_distributed_table('tpch.nation_hash', 'n_nationkey', 'hash');
SELECT master_create_worker_shards('tpch.nation_hash', 4, 1);

-- now drop the shards
SELECT master_apply_delete_command('DELETE FROM tpch.nation_hash');

CREATE TABLE tpch.nation_hash_2 (
    n_nationkey integer not null,
    n_name char(25) not null,
    n_regionkey integer not null,
    n_comment varchar(152));

SELECT master_create_distributed_table('tpch.nation_hash_2', 'n_nationkey', 'hash');
SELECT master_create_worker_shards('tpch.nation_hash_2', 4, 1);


CREATE TABLE tpch.nation_append_2 (
    n_nationkey integer not null,
    n_name char(25) not null,
    n_regionkey integer not null,
    n_comment varchar(152));
SELECT master_create_distributed_table('tpch.nation_append_2', 'n_nationkey', 'append');

\COPY tpch.nation_append_2 FROM '@abs_srcdir@/data/nation.data' with delimiter '|'

-- Set the search path to tpch and create -  drop shards
SET search_path TO tpch;

SELECT master_create_distributed_table('nation_hash', 'n_nationkey', 'hash');
SELECT master_create_worker_shards('nation_hash', 4, 1);

-- now drop the shards
SELECT master_apply_delete_command('DELETE FROM nation_hash');

-- now create the shards for the rest of the test
SELECT master_create_worker_shards('tpch.nation_hash', 4, 1);

-- create one more schema
CREATE SCHEMA tpch_2;
SET search_path to public;

-- Create the tables for the rest of the tests
CREATE TABLE tpch_2.nation_append (
    n_nationkey integer not null,
    n_name char(25) not null,
    n_regionkey integer not null,
    n_comment varchar(152));
SELECT master_create_distributed_table('tpch_2.nation_append', 'n_nationkey', 'append');

\COPY tpch_2.nation_append FROM '@abs_srcdir@/data/nation.data' with delimiter '|'

SELECT master_create_empty_shard('tpch_2.nation_append');
SELECT count(*) from tpch_2.nation_append;

CREATE TABLE tpch_2.nation_hash (
    n_nationkey integer not null,
    n_name char(25) not null,
    n_regionkey integer not null,
    n_comment varchar(152));

SELECT master_create_distributed_table('tpch_2.nation_hash', 'n_nationkey', 'hash');
SELECT master_create_worker_shards('tpch_2.nation_hash', 4, 2);

SET search_path TO public;
CREATE TABLE nation_local
(
    n_nationkey integer not null,
    n_name char(25) not null,
    n_regionkey integer not null,
    n_comment varchar(152));

\COPY public.nation_local FROM '@abs_srcdir@/data/nation.data' with delimiter '|'

SET search_path TO public;
CREATE TYPE tpch.new_composite_type as (key1 text, key2 text);

-- we need to create the composite types from the test rather than pg_regress.pl
-- since it depends on the schema
\c - - - :worker_1_port
CREATE TYPE tpch.new_composite_type as (key1 text, key2 text);

\c - - - :worker_2_port
CREATE TYPE tpch.new_composite_type as (key1 text, key2 text);

-- connect back to the master
\c - - - :master_port

CREATE TABLE tpch.nation_hash_with_composites (
    n_nationkey integer not null,
    n_name char(25) not null,
    n_regionkey integer not null,
    n_comment varchar(152),
    test_col tpch.new_composite_type
    );

SELECT master_create_distributed_table('tpch.nation_hash_with_composites', 'n_nationkey', 'hash');
SELECT master_create_worker_shards('tpch.nation_hash_with_composites', 4, 2);

\COPY nation_hash_with_composites FROM '@abs_srcdir@/data/nation.data' with delimiter '|'

-- create lineitem table as well
CREATE TABLE tpch.lineitem (
    l_orderkey bigint not null,
    l_partkey integer not null,
    l_suppkey integer not null,
    l_linenumber integer not null,
    l_quantity decimal(15, 2) not null,
    l_extendedprice decimal(15, 2) not null,
    l_discount decimal(15, 2) not null,
    l_tax decimal(15, 2) not null,
    l_returnflag char(1) not null,
    l_linestatus char(1) not null,
    l_shipdate date not null,
    l_commitdate date not null,
    l_receiptdate date not null,
    l_shipinstruct char(25) not null,
    l_shipmode char(10) not null,
    l_comment varchar(44) not null,
     PRIMARY KEY(l_orderkey, l_linenumber) );

SELECT master_create_distributed_table('tpch.lineitem', 'l_orderkey', 'hash');
SELECT master_create_worker_shards('tpch.lineitem', 16, 1);

COPY tpch.lineitem FROM '@abs_srcdir@/data/lineitem.1.data' with delimiter '|';
COPY tpch.lineitem FROM '@abs_srcdir@/data/lineitem.2.data' with delimiter '|';

CREATE TABLE tpch.orders (
    o_orderkey bigint not null,
    o_custkey integer not null,
    o_orderstatus char(1) not null,
    o_totalprice decimal(15,2) not null,
    o_orderdate date not null,
    o_orderpriority char(15) not null,
    o_clerk char(15) not null,
    o_shippriority integer not null,
    o_comment varchar(79) not null,
    PRIMARY KEY(o_orderkey) );

SELECT master_create_distributed_table('tpch.orders', 'o_orderkey', 'hash');
SELECT master_create_worker_shards('tpch.orders', 16, 1);

COPY tpch.orders FROM '@abs_srcdir@/data/orders.1.data' with delimiter '|';
COPY tpch.orders FROM '@abs_srcdir@/data/orders.2.data' with delimiter '|';

-- Test EXPLAIN on different search paths
-- TODO: add COSTS FALSE to explain as multi_explain.sql
SET search_path to tpch;
EXPLAIN SELECT * FROM nation_append;

SET search_path to public;
EXPLAIN SELECT * FROM tpch.nation_append;


-- Test worker_fetch_regular_table
SELECT count(*) FROM tpch.nation_append t1, tpch.nation_append_2 t2 WHERE t1.n_name = t2.n_name;

SET search_path TO tpch;
SELECT count(*) FROM nation_append t1, nation_append_2 t2 WHERE t1.n_name = t2.n_name;


-- now test master_append_table_to_shard, start with public schema
SET search_path TO public;

SELECT master_create_empty_shard('tpch.nation_append') AS new_shard_id
\gset

SELECT master_append_table_to_shard(:new_shard_id, 'nation_local', 'localhost', 5432);

-- now try on tpch schema
set search_path TO tpch;
SELECT master_append_table_to_shard(:new_shard_id, 'nation_local', 'localhost', 5432);



-- now explicitly check master_create_empty_shard on both schemas
SET search_path TO public;
SELECT master_create_empty_shard('tpch.nation_append');

SET search_path TO tpch;
SELECT master_create_empty_shard('nation_append');


-- Try modify/router queries
SET search_path TO public;
INSERT INTO tpch.nation_hash (n_nationkey) VALUES (26);
SELECT * FROM tpch.nation_hash WHERE n_nationkey = 25;


SET search_path TO tpch;
INSERT INTO nation_hash (n_nationkey) VALUES (26);
SELECT * FROM nation_hash WHERE n_nationkey = 25;

-- now test create / drop indexes
SET search_path TO public;
CREATE INDEX i1 ON tpch.nation_hash(n_name);
DROP INDEX tpch.i1;

SET search_path TO tpch;
CREATE INDEX i2 ON nation_hash(n_nationkey);
DROP INDEX i2;

-- now test COPY dist_table TO
SET search_path TO public;
COPY tpch.nation_hash TO STDOUT;

SET search_path TO tpch;
COPY nation_hash TO STDOUT;

-- now test CREATE TABLE AS
SET search_path TO public;
CREATE TABLE nation_copy_1 AS (SELECT * FROM tpch.nation_hash);

SET search_path TO tpch;
CREATE TABLE nation_copy_1 AS (SELECT * FROM nation_hash);

-- now test JOINS on/cross schemas
-- the tests includes co-located joins, range-repartition joins
-- and hash-repartition joins

-- start with co-located JOINs
SET search_path TO public;
SELECT
    count (*)
FROM
    tpch.nation_hash n1, tpch_2.nation_hash n2
WHERE
    n1.n_nationkey = n2.n_nationkey;


SET search_path TO tpch;
SELECT
    count (*)
FROM
    nation_hash n1, tpch_2.nation_hash n2
WHERE
    n1.n_nationkey = n2.n_nationkey;

SET search_path TO tpch_2;
SELECT
    count (*)
FROM
    tpch.nation_hash n1, nation_hash n2
WHERE
    n1.n_nationkey = n2.n_nationkey;

-- now test the tables that are on the same schema
SET search_path TO public;
SELECT
    count (*)
FROM
    tpch.nation_hash n1, tpch.nation_hash_2 n2
WHERE
    n1.n_nationkey = n2.n_nationkey;

SET search_path TO tpch;
SELECT
    count (*)
FROM
    nation_hash n1, nation_hash_2 n2
WHERE
    n1.n_nationkey = n2.n_nationkey;


-- now test single-repartition JOINs
SET search_path TO public;
SELECT
    count (*)
FROM
    tpch.nation_hash n1, tpch_2.nation_hash n2
WHERE
    n1.n_nationkey = n2.n_regionkey;

SET search_path TO tpch;
SELECT
    count (*)
FROM
    nation_hash n1, nation_hash_2 n2
WHERE
    n1.n_nationkey = n2.n_regionkey;

SET search_path TO tpch;
SELECT
    count (*)
FROM
    nation_hash n1, tpch_2.nation_hash n2
WHERE
    n1.n_nationkey = n2.n_regionkey;

SET search_path TO tpch_2;
SELECT
    count (*)
FROM
    nation_hash n1, tpch.nation_hash n2
WHERE
    n1.n_nationkey = n2.n_regionkey;

-- hash-repatitionin tests
SET search_path TO public;
SELECT
    count (*)
FROM
    tpch.nation_hash n1, tpch_2.nation_hash n2
WHERE
    n1.n_regionkey = n2.n_regionkey;

SET search_path TO tpch;
SELECT
    count (*)
FROM
    nation_hash n1, nation_hash_2 n2
WHERE
    n1.n_regionkey = n2.n_regionkey;

SET search_path TO tpch;
SELECT
    count (*)
FROM
    nation_hash n1, tpch_2.nation_hash n2
WHERE
    n1.n_regionkey = n2.n_regionkey;

SET search_path TO tpch_2;
SELECT
    count (*)
FROM
    tpch.nation_hash n1, nation_hash n2
WHERE
    n1.n_regionkey = n2.n_regionkey;


-- test master_copy_shard_placement()
SELECT shardid as newshardid FROM pg_dist_shard WHERE logicalrelid = 'tpch_2.nation_hash'::regclass LIMIT 1
\gset

-- now, update the second placement as unhealthy
UPDATE pg_dist_shard_placement SET shardstate = 3 WHERE shardid = :newshardid AND nodeport = :worker_2_port;

SET search_path TO tpch;
SELECT master_copy_shard_placement(:newshardid, 'localhost', :worker_1_port, 'localhost', :worker_2_port);

-- again, update the second placement as unhealthy
UPDATE pg_dist_shard_placement SET shardstate = 3 WHERE shardid = :newshardid AND nodeport = :worker_2_port;

SET search_path TO public;
SELECT master_copy_shard_placement(:newshardid, 'localhost', :worker_1_port, 'localhost', :worker_2_port);


-- test aggregation queries
SET search_path TO tpch ;
SELECT max(n_regionkey) FROM nation_hash ;

set search_path to public;
SELECT max(n_regionkey) FROM tpch.nation_hash ;

SET search_path TO tpch;
SELECT array_agg(n_name) FROM nation_hash GROUP BY n_regionkey
        ORDER BY n_regionkey LIMIT 10;

SET search_path TO public;
SELECT array_agg(n_name) FROM tpch.nation_hash GROUP BY n_regionkey
        ORDER BY n_regionkey LIMIT 10;

-- approximate aggreagtes
SET citus.count_distinct_error_rate TO 0.01;
SELECT COUNT (DISTINCT n_regionkey) FROM tpch.nation_hash;

SET search_path TO tpch ;
SELECT COUNT (DISTINCT n_regionkey) FROM nation_hash;


-- test UDF creation on different schemas

-- do this on both the master and workers
SET search_path TO public;
CREATE OR REPLACE FUNCTION dummyFunction(theValue integer)
    RETURNS text AS
$$
DECLARE
    strresult text;
BEGIN
    RETURN theValue * 3 / 2 + 1;
END;
$$
LANGUAGE 'plpgsql' IMMUTABLE;

SET search_path TO tpch;
CREATE OR REPLACE FUNCTION dummyFunction2(theValue integer)
    RETURNS text AS
$$
DECLARE
    strresult text;
BEGIN
    RETURN theValue * 3 / 2 + 1;
END;
$$
LANGUAGE 'plpgsql' IMMUTABLE;

\c - - - :worker_1_port
SET search_path TO public;
CREATE OR REPLACE FUNCTION dummyFunction(theValue integer)
    RETURNS text AS
$$
DECLARE
    strresult text;
BEGIN
    RETURN theValue * 3 / 2 + 1;
END;
$$
LANGUAGE 'plpgsql' IMMUTABLE;

SET search_path TO tpch;
CREATE OR REPLACE FUNCTION dummyFunction2(theValue integer)
    RETURNS text AS
$$
DECLARE
    strresult text;
BEGIN
    RETURN theValue * 3 / 2 + 1;
END;
$$
LANGUAGE 'plpgsql' IMMUTABLE;

\c - - - :worker_2_port
SET search_path TO public;
CREATE OR REPLACE FUNCTION dummyFunction(theValue integer)
    RETURNS text AS
$$
DECLARE
    strresult text;
BEGIN
    RETURN theValue * 3 / 2 + 1;
END;
$$
LANGUAGE 'plpgsql' IMMUTABLE;

SET search_path TO tpch;
CREATE OR REPLACE FUNCTION dummyFunction2(theValue integer)
    RETURNS text AS
$$
DECLARE
    strresult text;
BEGIN
    RETURN theValue * 3 / 2 + 1;
END;
$$
LANGUAGE 'plpgsql' IMMUTABLE;

-- connect back to the master
\c - - - :master_port

SET search_path TO public;
SELECT dummyFunction(n_nationkey) FROM tpch.nation_hash  GROUP BY 1;

-- works fine
SET search_path TO public;
SELECT dummyFunction(n_nationkey) FROM nation_hash  GROUP BY 1;

SET search_path TO public;
SELECT tpch.dummyFunction2(n_nationkey) FROM tpch.nation_hash  GROUP BY 1;

SET search_path TO tpch;
SELECT dummyFunction2(n_nationkey) FROM nation_hash  GROUP BY 1;

-- test composite type creation on different schemas
SET search_path TO public;
SELECT * FROM tpch.nation_hash_with_composites  WHERE test_col = '(a,a)'::tpch.new_composite_type;

SET search_path TO tpch;
SELECT * FROM nation_hash_with_composites WHERE test_col = '(a,a)'::new_composite_type;

-- test prepared statements
SET search_path TO public;
PREPARE preparedStatementCreatedOnPublic AS SELECT * FROM tpch.nation_hash;

SET search_path TO tpch;
PREPARE preparedStatementCreatedOnTPCH1 AS SELECT * FROM nation_hash;

SET search_path TO public;
EXECUTE preparedStatementCreatedOnPublic;
EXECUTE preparedStatementCreatedOnTPCH1;

SET search_path TO tpch;
EXECUTE preparedStatementCreatedOnPublic;
EXECUTE preparedStatementCreatedOnTPCH1;

-- try on real-time executor
SET search_path TO public;
BEGIN;
DECLARE test_cursor CURSOR FOR
    SELECT *
        FROM tpch.nation_hash;
        FETCH test_cursor;
FETCH test_cursor;
END;

SET search_path TO tpch;
BEGIN;
DECLARE test_cursor CURSOR FOR
    SELECT *
        FROM nation_hash;
        FETCH test_cursor;
FETCH test_cursor;
END;

-- try on router executor
SET search_path TO public;
BEGIN;
DECLARE test_cursor CURSOR FOR
    SELECT *
        FROM tpch.nation_hash
        WHERE n_nationkey = 1;
        FETCH test_cursor;
FETCH test_cursor;
END;

SET search_path TO tpch;
BEGIN;
DECLARE test_cursor CURSOR FOR
    SELECT *
        FROM nation_hash
        WHERE n_nationkey = 1;
        FETCH test_cursor;
FETCH test_cursor;
END;

-- Tests including single table repartition and subquery pushdown
SET search_path TO public;
SET citus.task_executor_type TO 'task-tracker';
select
    total,
    avg(avg_count) as total_avg_count
from
    (select
        number_sum,
        count(*) as total,
        avg(total_count) avg_count
    from
        (select
            l_suppkey,
            sum(l_linenumber) as number_sum,
            count(*) as total_count
        from
            tpch.lineitem
        where
            l_partkey > 100 and
            l_quantity > 2 and
            l_orderkey < 10000
        group by
            l_suppkey) as distributed_table
    where
        number_sum >= 10
    group by
        number_sum) as distributed_table_2
group by
    total
order by
    total;


SET search_path TO tpch;
select
    total,
    avg(avg_count) as total_avg_count
from
    (select
        number_sum,
        count(*) as total,
        avg(total_count) avg_count
    from
        (select
            l_suppkey,
            sum(l_linenumber) as number_sum,
            count(*) as total_count
        from
            lineitem
        where
            l_partkey > 100 and
            l_quantity > 2 and
            l_orderkey < 10000
        group by
            l_suppkey) as distributed_table
    where
        number_sum >= 10
    group by
        number_sum) as distributed_table_2
group by
    total
order by
    total;


-- now test with subquery pushdown

SET citus.subquery TO on;
SET search_path TO public;
SELECT
    avg(unit_price)
FROM
    (SELECT
        l_orderkey,
        avg(o_totalprice / l_quantity) AS unit_price
    FROM
        tpch.lineitem,
        tpch.orders
    WHERE
        l_orderkey = o_orderkey
    GROUP BY
        l_orderkey) AS unit_prices
WHERE
    unit_price > 1000 AND
    unit_price < 10000;

SET search_path TO tpch;
SELECT
    avg(unit_price)
FROM
    (SELECT
        l_orderkey,
        avg(o_totalprice / l_quantity) AS unit_price
    FROM
        lineitem,
        orders
    WHERE
        l_orderkey = o_orderkey
    GROUP BY
        l_orderkey) AS unit_prices
WHERE
    unit_price > 1000 AND
    unit_price < 10000;



-- test ALTER TABLE commands
SET search_path TO public;

-- add column
ALTER TABLE tpch.nation_hash ADD COLUMN tmp_col INT;

-- drop column
ALTER TABLE tpch.nation_hash  DROP COLUMN IF EXISTS non_existent_column;

-- ALTER TABLE on tpch schema
SET search_path TO tpch;
ALTER TABLE nation_hash ADD COLUMN tmp_col_2 INT;
ALTER TABLE nation_hash  DROP COLUMN IF EXISTS non_existent_column;
ALTER TABLE nation_hash ALTER COLUMN n_comment SET DEFAULT 'comment';

-- test master_modify_multiple_shards()
SET search_path TO public;
SELECT master_modify_multiple_shards('UPDATE tpch.nation_hash SET n_regionkey = n_regionkey + 1');

SET search_path TO tpch;
SELECT master_modify_multiple_shards('UPDATE nation_hash SET n_regionkey = n_regionkey + 1');

-- now set schema of table
SET search_path TO public;

ALTER TABLE nation_local SET SCHEMA tpch;
SELECT count(*) FROM tpch.nation_local;

ALTER TABLE tpch.nation_local SET SCHEMA public;
SELECT count(*) FROM nation_local;

SET search_path TO public;
ALTER TABLE nation_local SET SCHEMA tpch;
SELECT count(*) FROM tpch.nation_local;

SET search_path TO tpch;
ALTER TABLE nation_local SET SCHEMA tpch;
SELECT count(*) FROM nation_local;



-- test master_drop_all_shards()

SET search_path TO public;
SELECT master_drop_all_shards('tpch.nation_hash'::regclass, 'tpch', 'nation_hash');

-- add new shard
SELECT master_create_worker_shards('tpch.nation_hash', 4, 1);

SET search_path TO tpch;
SELECT master_drop_all_shards('nation_hash'::regclass, 'tpch', 'nation_hash');

-- test master_get_table_metadata()
SET search_path TO public;
SELECT * FROM master_get_table_metadata('tpch.nation_hash');

SET search_path TO tpch;
SELECT * FROM master_get_table_metadata('nation_hash');

-- test master_get_table_ddl_events()
SET search_path TO public;
SELECT * FROM master_get_table_ddl_events('tpch.nation_hash');

SET search_path TO tpch;
SELECT * FROM master_get_table_ddl_events('nation_hash');


-- test master_update_shard_statistics()
SET search_path TO public;
SELECT master_create_empty_shard('tpch.nation_append') AS new_shard_id
\gset

SET search_path TO public;
SELECT * FROM master_update_shard_statistics(:new_shard_id);


SET search_path TO tpch;
SELECT * FROM master_update_shard_statistics(:new_shard_id);


-- test DROP TABLE
SET search_path TO public;
DROP TABLE tpch.nation_hash;

SET search_path TO tpch;
DROP TABLE nation_hash;

SET search_path TO public;
DROP SCHEMA tpch CASCADE;
DROP SCHEMA tpch_2 CASCADE;
